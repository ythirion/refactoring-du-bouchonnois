# "Event Sourcing"
Nous avons des `ersatzs` d'√©v√©nements au sein de notre `PartieDeChasse`. 

Ceux-ci sont extr√™mement limit√©s :
- ils ne portent aucune s√©mantique m√©tier
- pas structur√©s : ce sont de simples `string`

```csharp
private readonly List<Event> _events;
public sealed record Event(DateTime Date, string Message)
{
    public override string ToString() => string.Format("{0:HH:mm} - {1}", Date, Message);
}

if (TousBrocouilles(classement))
{
    result = "Brocouille";
    EmitEvent("La partie de chasse est termin√©e, vainqueur : Brocouille", timeProvider);
}
else
{
    result = Join(", ", classement[0].Select(c => c.Nom));
    EmitEvent(
        $"La partie de chasse est termin√©e, vainqueur : {Join(", ", classement[0].Select(c => $"{c.Nom} - {c.NbGalinettes} galinettes"))}",
        timeProvider);
}
```

On va revoir cette gestion des √©v√©nements et allons en profiter pour `Event-sourcer` notre `Aggregate`. Cel√† signifie que nous n'allons plus stocker l'√©tat de notre `Aggregate` mais tous ses √©v√©nements.

Pour cel√†, on va :
- Prendre du temps pour d√©couvrir ce qu'est l'[`Event Sourcing`](https://martinfowler.com/eaaDev/EventSourcing.html)
- Quelques classes ont d√©j√† √©t√© impl√©ment√© afin de faciliter l'utilisation d'1 `Event Store` in memory
  - Faire 1 `checkout` du commit `6efde7c3e470e7c84c50da2715c255bd9acd3d6c`

```shell
git checkout 5b3129f2bc384ccc707b3f6bb730ff2ef9999167
```

- Cette version est tr√®s minimaliste et ne r√©solve pas des probl√©matiques telles que la concurrence
- Prendre du temps pour comprendre le code du `Domain.Core`
  - Ce code est fortement inspir√© du travail fait sur [`NEventStore`](https://github.com/NEventStore/NEventStore)
  - Pour comprendre comment utiliser ce code, on peut se focaliser sur les tests qui nous en donnent une bonne id√©e

```csharp
[Fact]
public class AggregateShould
{
    private readonly Guid _id;
    private readonly Movie _movie;

    public AggregateShould()
    {
        _id = Guid.NewGuid();
        _movie = Oppenheimer.Movie(_id);
    }

    [Fact]
    public void have_raised_creation_event()
    {
        _movie.HasRaisedEvent(new MovieCreated(_id, Data.Now, Oppenheimer.Title, Oppenheimer.ReleaseDate))
            .Should()
            .BeTrue();
        _movie.Version.Should().Be(1);
        _movie.Id.Should().Be(_id);
    }

    [Fact]
    public void have_raised_casting_changed_event()
    {
        var newCasting = new List<string> {"Cillian Murphy", "Florence Pugh"}.ToSeq();

        _movie.ChangeCast(newCasting);

        _movie.HasRaisedEvent(new CastingHasChanged(_id, Data.Now, newCasting))
            .Should()
            .BeTrue();

        _movie.Version.Should().Be(2);
    }

    [Fact]
    public void throw_handler_not_found_when_apply_method_not_defined()
    {
        var act = () => _movie.NotWellImplementedBehavior();
        act.Should()
            .Throw<HandlerForDomainEventNotFoundException>()
            .WithMessage(
                "Aggregate of type 'Movie' raised an event of type 'NotWellImplementedDomainBehaviorRaised' but no handler could be found to handle the event.");
    }
    ...
}

public class Movie : Aggregate
{
    // public only for testing purpose
    public string? _title;
    public DateTime? _releaseDate;
    public Seq<string> _casting = Seq<string>.Empty;
    private Movie(Guid id, Func<DateTime> timeProvider) : base(timeProvider, true) => Id = id;

    public Movie(Guid id, Func<DateTime> timeProvider, string title, DateTime releaseDate) : this(id, timeProvider)
        => RaiseEvent(new MovieCreated(id, Time(), title, releaseDate));

    private void Apply(MovieCreated @event)
    {
        _title = @event.Title;
        _releaseDate = @event.ReleaseDate;
    }

    public void ChangeCast(Seq<string> casting) => RaiseEvent(new CastingHasChanged(Id, Time(), casting));

    private void Apply(CastingHasChanged @event) => _casting = @event.Casting;

    public void NotWellImplementedBehavior() => RaiseEvent(new NotWellImplementedDomainBehaviorRaised(Id, Time()));
}

public record MovieCreated(Guid Id, DateTime Date, string Title, DateTime ReleaseDate) : Event(Id, 1, Date);

public record CastingHasChanged(Guid Id, DateTime Date, Seq<string> Casting) : Event(Id, 1, Date);

public record NotWellImplementedDomainBehaviorRaised(Guid Id, DateTime Date) : Event(Id, 1, Date);
```

- Identifier quels sont les √©l√©ments fondamentaux √† mettre en place pour avoir 1 `Aggregate` "Event-Sourc√©"

## Changer l'impl√©mentation de `Prendre LAp√©ro`
Faire en sorte que le flux ressemble √† cel√† :

![Events](img/12.event-sourcing/events.webp)

- Pour le moment au sein de notre `Domain` son impl√©mentation ressemble √† √ßa :

```csharp
public Either<Error, PartieDeChasse> PrendreLap√©ro(Func<DateTime> timeProvider)
{
    if (DuringAp√©ro())
    {
        return AnError("On est d√©j√† en plein ap√©ro");
    }

    if (D√©j√†Termin√©e())
    {
        return AnError("La partie de chasse est d√©j√† termin√©e");
    }

    Status = Ap√©ro;
    EmitEvent("Petit ap√©ro", timeProvider);

    return this;
}
```

- Soyons plus explicite en retournant `Either<Error, Unit>`
  - On ne stockera plus l'√©tat mais que les `Events` donc plus besoin de retourner le nouvel √©tat de l'objet

- :red_circle: On commence par adapter 1 test existant afin de sp√©cifier nos attentes vis-√†-vis du syst√®me
  - On change le test 
  - On utilise 1 verbe au pass√© pour d√©crire notre √©v√©nement -> quelque chose d'immuable

![First red test](img/12.event-sourcing/red-apero.webp)

- On g√©n√®re l'Event "structur√©" depuis le test
  - On choisi d'utiliser 1 `record` parce qu'ils sont immuables par design
  - On ajoute la r√©f√©rence sur le projet `Domain.Core`

```csharp
public record Ap√©roD√©marr√©(Guid Id, DateTime Date) : Event(Id, 1, Date);
```

- On doit maintenant ajouter 1 `overload` sur notre class `PartieDeChasseAssertions` afin de pouvoir faire des assertions sur des Domain Events :

```csharp
public AndConstraint<PartieDeChasseAssertions> HaveEmittedEvent<TEvent>(TEvent expectedEvent) where TEvent : class, IEvent 
    => // Comment √©crire cette Assertion ???
```

- On doit v√©rifier que l'√©v√©nemt a bien √©t√© √©mis par notre aggr√©gat et commit√© dans notre `EventStore`
  - On va donc v√©rifier que dans le `stream` d'events associ√© √† l'instance de notre aggr√©gat notre `event` est bien pr√©sent
  - On ajoute alors dans l'assertion 1 d√©pendance sur le repository

```csharp
        public AndConstraint<PartieDeChasseAssertions> HaveEmittedEvent<TEvent>(
            IPartieDeChasseRepository repository,
            TEvent expectedEvent) where TEvent : class, IEvent =>
            Call(() => Assertion
                .Given(() => repository.EventsFor(Subject!.Id)) // devra retourner 1 Seq<IEvent>
                .ForCondition(events => events.Exists(stream => stream.Exists(@event => @event.Equals(expectedEvent))))
                .FailWith($"Les events devraient contenir {expectedEvent}."));
```

- Pour continuer on doit it√©rer sur notre `interface` de repository
  - On commence √† inclure de l'asynchronisme en utilisant 1 `OptionAsync` (toujours de `LanguageExt`)
  - On adapte aussi l'assertion (on va utiliser l'`AsyncHelper` pour se faciliter la t√¢che)

```csharp
public interface IPartieDeChasseRepository
{
    void Save(PartieDeChasse partieDeChasse);
    Option<PartieDeChasse> GetById(Guid partieDeChasseId);
    // On va utiliser des m√©canismes Async pour refl√©ter l'asynchronisme de notre Event Store
    OptionAsync<Seq<IEvent>> EventsFor(Guid partieDeChasseId);
}

public AndConstraint<PartieDeChasseAssertions> HaveEmittedEvent<TEvent>(
    IPartieDeChasseRepository repository,
    TEvent expectedEvent) where TEvent : class, IEvent =>
    Call(() => Assertion
            .Given(() => repository.EventsFor(Subject!.Id))
            .ForCondition(events => AsyncHelper.RunSync(() => events.Exists(stream => stream.Exists(@event => @event.Equals(expectedEvent)))))
            .FailWith($"Les events devraient contenir {expectedEvent}.")
    );
```

- On ajoute 1 instance d'`EventStore` au sein du `PartieDeChasseRepositoryForTests`
  - Sachant que pour les besoins de testing nous utiliserons l'instance `InMemory`
  - Ce repository permettra de mani√®re transiente de pouvoir faire du state-based et de l'event sourcing

```csharp
public class PartieDeChasseRepositoryForTests : IPartieDeChasseRepository
{
    private readonly IEventStore _eventStore;
    private Map<Guid, PartieDeChasse> _partiesDeChasse = Map<Guid, PartieDeChasse>.Empty;
    private PartieDeChasse? _savedPartieDeChasse;

    public PartieDeChasseRepositoryForTests(IEventStore eventStore)
        => _eventStore = eventStore;

    public void Save(PartieDeChasse partieDeChasse)
    {
        ((IAggregate) partieDeChasse).GetUncommittedEvents().ToSeq();
        // On sauvegarde l'aggr√©gat via l'EventStore
        AsyncHelper.RunSync(() => _eventStore.Save(partieDeChasse));

        _savedPartieDeChasse = partieDeChasse;
        Add(partieDeChasse);
    }
    
    ...
    
    public OptionAsync<Seq<IEvent>> EventsFor(Guid partieDeChasseId)
        => _eventStore
            .GetEventsById<PartieDeChasse>(partieDeChasseId)
            .Map(events => events.OrderByDescending(e => e.Date).ToSeq());
            
    ...
}
```

- On adapte ses instantiations

```csharp
protected UseCaseTest(Func<IPartieDeChasseRepository, Func<DateTime>, TUseCase> useCaseFactory)
{
    Repository = new PartieDeChasseRepositoryForTests(new InMemoryEventStore(TimeProvider));
    _useCase = useCaseFactory(Repository, TimeProvider);
}
```

- On doit maintenant travailler sur l'Aggregate

![PartieDeChasse is not an aggregate](img/12.event-sourcing/aggregate-es.webp)

- On lui fait h√©riter de `Aggregate` et on fixe les warnings

```csharp
public sealed class PartieDeChasse : Aggregate
{
    private readonly Arr<Chasseur> _chasseurs = Arr<Chasseur>.Empty;
    // TODO : √† supprimer √† terme
    private readonly List<Event> _events = new();
    public IReadOnlyList<Chasseur> Chasseurs => _chasseurs.ToImmutableArray();
    public Terrain? Terrain { get; }
    public PartieStatus Status { get; private set; }
    public IReadOnlyList<Event> Events => _events.ToImmutableArray();

    // Nouveau ctor    
    private PartieDeChasse(Guid id, Func<DateTime> timeProvider) : base(timeProvider) => Id = id;

    private PartieDeChasse(Guid id,
        Func<DateTime> timeProvider,
        Terrain terrain,
        Chasseur[] chasseurs)
        : this(id, timeProvider)
    {
        Id = id;
        _chasseurs = chasseurs.ToArr();
        Terrain = terrain;
        Status = EnCours;
        _events = new List<Event>();

        EmitPartieD√©marr√©e(timeProvider);
    }
```

- :red_circle: On fail maintenant plus pour des erreurs de compilation mais bien parce qu'aucun √©v√©nement n'est pr√©sent dans l'`Event Store`

![Fail car aucun √©v√©nement trouv√©](img/12.event-sourcing/failfor-event.webp)

- :green_circle: On `raise` l'event

```csharp
public Either<Error, PartieDeChasse> PrendreLap√©ro(Func<DateTime> timeProvider)
{
    if (DuringAp√©ro())
    {
        return AnError("On est d√©j√† en plein ap√©ro");
    }

    if (D√©j√†Termin√©e())
    {
        return AnError("La partie de chasse est d√©j√† termin√©e");
    }

    Status = Ap√©ro;
    RaiseEvent(new Ap√©roD√©marr√©(Id, timeProvider()));
    EmitEvent("Petit ap√©ro", timeProvider);

    return this;
}
```

- :large_blue_circle: On va d√©sormais adapt√© notre code pour faire en sorte que cet √©v√©nement puisse √™tre rejou√© sur l'aggr√©gat
  - La transition (mutation / changement d'√©tat doit se faire au chargement de l'event) ici `Status = Ap√©ro`

```csharp
public Either<Error, PartieDeChasse> PrendreLap√©ro(Func<DateTime> timeProvider)
{
    if (DuringAp√©ro())
    {
        return AnError("On est d√©j√† en plein ap√©ro");
    }

    if (D√©j√†Termin√©e())
    {
        return AnError("La partie de chasse est d√©j√† termin√©e");
    }

    RaiseEvent(new Ap√©roD√©marr√©(Id, timeProvider()));
    // On supprimera la m√©thode EmitEvent une fois qu'on aura finit de changer chaque behavior de l'aggr√©gat
    EmitEvent("Petit ap√©ro", timeProvider);

    return this;
}

// Attention : cette m√©thode sera appel√© par Reflection -> votre IDE voudra la supprim√©e...
// Vos tests diront le contraire üòâ
private void Apply(Ap√©roD√©marr√© @event) => Status = Ap√©ro;
```

- :large_blue_circle: On va changer le retour de la m√©thode √† partir de l'appelant

```csharp
protected static Either<Error, VoidResponse> ToEmpty(Either<Error, Unit> either)
    => either.Map(_ => VoidResponse.Empty);
    

public Either<Error, Unit> PrendreLap√©ro(Func<DateTime> timeProvider)
{
    if (DuringAp√©ro())
    {
        return AnError("On est d√©j√† en plein ap√©ro");
    }

    if (D√©j√†Termin√©e())
    {
        return AnError("La partie de chasse est d√©j√† termin√©e");
    }

    RaiseEvent(new Ap√©roD√©marr√©(Id, timeProvider()));
    EmitEvent("Petit ap√©ro", timeProvider);

    return Default;
}
```

## Reflect
- Qu'est-ce que cel√† a simplifi√© ?
- Au contraire complexifi√© ?
- Qu'est ce que tu en penses ?
![Event Sourcing](img/12.event-sourcing/event-sourcing.webp)
